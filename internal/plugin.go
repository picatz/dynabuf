package dynabuf

import (
	"context"
	"fmt"

	"github.com/bufbuild/protoplugin"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// Handle is the main entry point for the plugin.
func Handle(ctx context.Context, env protoplugin.PluginEnv, w protoplugin.ResponseWriter, r protoplugin.Request) error {
	plugin, err := protogen.Options{}.New(r.CodeGeneratorRequest())
	if err != nil {
		return fmt.Errorf("failed to create plugin: %w", err)
	}

	w.SetFeatureProto3Optional()

	fileDescriptors, err := r.FileDescriptorsToGenerate()
	if err != nil {
		return fmt.Errorf("failed to get file descriptors to generate: %w", err)
	}

	for _, fileDescriptor := range fileDescriptors {
		pluginFile := plugin.FilesByPath[fileDescriptor.Path()]

		messages := fileDescriptor.Messages()

		if messages.Len() == 0 {
			continue
		}

		fileName := fmt.Sprintf("%s.pb.dynabuf.go", pluginFile.GeneratedFilenamePrefix)

		generatedFile := plugin.NewGeneratedFile(fileName, pluginFile.GoImportPath)

		generatedFile.P("// Code generated by protoc-gen-go-dynabuf. DO NOT EDIT.\n")
		generatedFile.P(fmt.Sprintf("package %s", pluginFile.GoPackageName))

		for i := 0; i < messages.Len(); i++ {
			message := messages.Get(i)

			pluginFileMessage := pluginFile.Messages[i]

			var (
				partitionKey *protogen.Field
				sortKey      *protogen.Field
			)

			for j := 0; j < message.Fields().Len(); j++ {
				field := message.Fields().Get(j)

				fieldOptions, ok := proto.GetExtension(field.Options(), E_Field).(*Field)
				if !ok {
					continue
				}

				if fieldOptions.GetPartitionKey() {
					partitionKey = pluginFileMessage.Fields[j]
				}

				if fieldOptions.GetSortKey() {
					sortKey = pluginFileMessage.Fields[j]
				}
			}

			if partitionKey != nil {
				err = generateTableFunctions(generatedFile, message, partitionKey, sortKey)
				if err != nil {
					return fmt.Errorf("failed to generate table functions: %w", err)
				}

				generatePrimaryKeyMethod(generatedFile, pluginFileMessage, partitionKey, sortKey)
				generateKeyConditionMethod(generatedFile, pluginFileMessage, partitionKey, sortKey)
			} else {
				generatedFile.Skip()
			}
		}
	}

	response := plugin.Response()
	w.AddCodeGeneratorResponseFiles(response.GetFile()...)
	w.SetError(response.GetError())

	return nil
}

// generatePrimaryKeyMethod generates the PrimaryKey method for the message type.
func generatePrimaryKeyMethod(generatedFile *protogen.GeneratedFile, message *protogen.Message, partitionKey, sortKey *protogen.Field) error {
	generatedFile.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "AttributeValue",
		GoImportPath: "github.com/aws/aws-sdk-go-v2/service/dynamodb/types",
	})

	if partitionKey == nil {
		return fmt.Errorf("partition key is required")
	}

	partitionType, err := protoTypeToDynamoType(partitionKey)
	if err != nil {
		return fmt.Errorf("failed to convert partition key type: %w", err)
	}

	partitionExpr := fmt.Sprintf(`%q: &types.AttributeValueMember%s{Value: m.%s},`, partitionKey.Desc.JSONName(), partitionType, partitionKey.GoName)

	var sortExpr string
	if sortKey != nil {
		sortType, err := protoTypeToDynamoType(sortKey)
		if err != nil {
			return fmt.Errorf("failed to convert sort key type: %w", err)
		}

		sortExpr = fmt.Sprintf(`%q: &types.AttributeValueMember%s{Value: m.%s},`, sortKey.Desc.JSONName(), sortType, sortKey.GoName)
	}

	fn := fmt.Sprintf(`
	// PrimaryKey returns the primary key to use with DynamoDB.
	//
	// This is either a single attribute (a partition key) or a composite key 
	// (a partition key and a sort key). The primary key is used to uniquely
	// identify an item in a table.
	func (m *%[1]s) PrimaryKey() map[string]types.AttributeValue { 
		return map[string]types.AttributeValue{
			%[2]s
			%[3]s
		}
	}`, message.GoIdent.GoName, partitionExpr, sortExpr)

	generatedFile.P(fn)

	return nil
}

// protoTypeToDynamoType converts a protogen field to a DynamoDB attribute member type.
func protoTypeToDynamoType(field *protogen.Field) (string, error) {
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		return "S", nil
	case protoreflect.Int32Kind, protoreflect.Int64Kind, protoreflect.Uint32Kind, protoreflect.Uint64Kind:
		return "N", nil
	case protoreflect.BytesKind:
		return "B", nil
	default:
		return "", fmt.Errorf("unsupported type: %s", field.Desc.Kind())
	}
}

// generateKeyConditionMethod generates the KeyCondition method for the message type.
func generateKeyConditionMethod(generatedFile *protogen.GeneratedFile, message *protogen.Message, partitionKey, sortKey *protogen.Field) error {
	generatedFile.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "KeyConditionBuilder",
		GoImportPath: "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression",
	})

	if partitionKey == nil {
		return fmt.Errorf("partition key is required")
	}

	partitionExpr := fmt.Sprintf(`expression.Key(%q).Equal(expression.Value(m.%s))`, partitionKey.Desc.JSONName(), partitionKey.GoName)

	var sortExpr string
	if sortKey != nil {
		sortExpr = fmt.Sprintf(`expression.Key(%q).Equal(expression.Value(m.%s))`, sortKey.Desc.JSONName(), sortKey.GoName)
	}

	combinedExpr := partitionExpr

	if sortExpr != "" {
		combinedExpr = fmt.Sprintf(`%s.And(%s)`, partitionExpr, sortExpr)
	}

	fn := fmt.Sprintf(`
	// KeyCondition returns the key condition to use with DynamoDB expressions.
	//
	// This is either a single attribute (a partition key) or a composite key
	// (a partition key and a sort key). The key condition is used to query
	// items in a table.
	func (m *%[1]s) KeyCondition() expression.KeyConditionBuilder { 
		return %[2]s 
	}`, message.GoIdent.GoName, combinedExpr)

	generatedFile.P(fn)

	return nil
}

// generateTableFunctions generates the table functions for the file descriptor.
func generateTableFunctions(generatedFile *protogen.GeneratedFile, msg protoreflect.MessageDescriptor, partitionKey, sortKey *protogen.Field) error {
	generatedFile.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "Context",
		GoImportPath: "context",
	})

	generatedFile.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "Config",
		GoImportPath: "github.com/aws/aws-sdk-go-v2/aws",
	})

	generatedFile.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "Client",
		GoImportPath: "github.com/aws/aws-sdk-go-v2/service/dynamodb",
	})

	tables, ok := proto.GetExtension(msg.Options(), E_Table).([]*Table)
	if !ok {
		return fmt.Errorf("table options not found")
	}

	for _, table := range tables {
		partitionKeyAttrDefType, err := protoTypeToDynamoType(partitionKey)
		if err != nil {
			return fmt.Errorf("failed to convert partition key type: %w", err)
		}

		partitionKeyAttrDefExpr := fmt.Sprintf(`{
			AttributeName: aws.String(%[1]q),
			AttributeType: types.ScalarAttributeType%[2]s,
		},`, partitionKey.Desc.Name(), partitionKeyAttrDefType)

		var sortKeyAttrDefExpr string
		var sortKeyAttrKeyExpr string
		if sortKey != nil {
			sortKeyAttrDefType, err := protoTypeToDynamoType(sortKey)
			if err != nil {
				return fmt.Errorf("failed to convert sort key type: %w", err)
			}

			sortKeyAttrDefExpr = fmt.Sprintf(`{
				AttributeName: aws.String(%[1]q),
				AttributeType: types.ScalarAttributeType%[2]s,
			},`, sortKey.Desc.Name(), sortKeyAttrDefType)

			sortKeyAttrKeyExpr = fmt.Sprintf(`{
				AttributeName: aws.String(%[1]q),
				KeyType:       types.KeyTypeRange,
			},`, sortKey.Desc.Name())
		}

		var billingMode string
		switch table.GetBillingMode() {
		case Table_BILLING_MODE_UNSPECIFIED, Table_BILLING_MODE_PAY_PER_REQUEST:
			billingMode = "types.BillingModePayPerRequest"
		case Table_BILLING_MODE_PROVISIONED:
			billingMode = "types.BillingModeProvisioned"
		default:
			return fmt.Errorf("unknown billing mode: %v", table.GetBillingMode())
		}

		generatedFile.P(fmt.Sprintf(`
		// TableName_%[1]s is the name of the %[1]s table in DynamoDB.
		var TableName_%[1]s = aws.String(%[1]q)

		// CreateTable_%[1]s creates the %[1]s table in DynamoDB. If there are any issues
		// creating the table, an error will be returned.
		func CreateTable_%[1]s(ctx context.Context, dynamoClient *dynamodb.Client) error {
			_, err := dynamoClient.CreateTable(
				ctx,
				&dynamodb.CreateTableInput{
					TableName:   TableName_%[1]s,
					AttributeDefinitions: []types.AttributeDefinition{
						%[2]s
						%[4]s
					},
					KeySchema: []types.KeySchemaElement{
						{
							AttributeName: aws.String(%[3]q),
							KeyType:       types.KeyTypeHash,
						},
						%[5]s
					},
					BillingMode: %[6]s,
				},
			)
			return err
		}
		`,
			table.GetName(),          // 1
			partitionKeyAttrDefExpr,  // 2
			partitionKey.Desc.Name(), // 3
			sortKeyAttrDefExpr,       // 4
			sortKeyAttrKeyExpr,       // 5
			billingMode,              // 6
		))
	}

	return nil
}
